---
description: 
globs: 
alwaysApply: false
---
# Guidelines for creating new API endpoints using TS-REST in the project.

# Feature Creation: Implementing New API Endpoints

This guide outlines the standardized process for implementing new API endpoints using TS-REST within this project. Adhering to these guidelines ensures consistency, maintainability, and proper testing of all API functionalities.

## 1. Creating a New API Endpoint

All API endpoints are defined using the TS-REST framework, which enforces strong typing and consistency between the frontend client and backend implementation.

### 1.1 Define the TS-REST Contract

Each API endpoint begins with a contract definition. This contract specifies the method, path, request body schema, and response schemas (including success and error responses).

-   **Location:** `src/app/api/v1/_contracts/<feature-area>/<endpoint-name>.ts`
-   **Example Structure (from existing contracts):**

    ```typescript
    // src/app/api/v1/_contracts/roles/getRoles.ts
    import { initContract } from "@ts-rest/core";
    import { z } from "zod";
    import { extendZodWithOpenApi } from "@anatine/zod-openapi";
    import { ErrorResponse, Role, ResourceType } from "../schema";

    extendZodWithOpenApi(z);

    const c = initContract();

    export const contract = c.router(
      {
        contract: { // this must be named contract as per my setup in this project
          method: "GET",
          path: "/roles",
          query: z.object({
            resourceType: ResourceType.openapi({
              description: "The type of resource to fetch roles for.",
            }),
            resourcePath: z.string().openapi({
              description:
                "The hierarchical path of the resource (e.g., 'org:uuid' or 'org:uuid/team:uuid').",
            }),
          }),
          responses: {
            200: z.array(Role),
            400: ErrorResponse,
            401: ErrorResponse,
            404: ErrorResponse,
            500: ErrorResponse,
          },
          metadata: {
            openApiTags: ["Roles"],
            openApiSecurity: [{ bearerAuth: [] }],
          },
          summary: "Retrieve roles by resource type and path",
          description: "Retrieve all roles associated with a given resource type and its hierarchical path.",
        },
      },
      {
        strictStatusCodes: true,
      }
    );
    ```

### 1.2 Implement the API Endpoint

After defining the contract, implement the logic for the endpoint.

-   **Location:** `src/app/api/v1/_contracts/<feature-area>/<endpoint-name>.ts` (within the same file as the contract).
-   **Middleware:**
    -   All protected routes **must** use the `@secureByAuthentication` middleware. This middleware handles JWT validation, ensuring that only authenticated requests can access the endpoint.
    -   **Usage:**
        ```typescript
        // src/app/api/v1/_contracts/roles/getRoles.ts (example excerpt)
        import { tsr } from "@ts-rest/serverless/next";
        import { secureByAuthentication } from "../auth-utils";
        import { JwtPayloadSchema } from "../schema"; // Import JwtPayloadSchema for middleware typing

        // ... (contract definition) ...

        type ContractRequest = ServerInferRequest<typeof contract.getRoles>;
        type ContractResponse = ServerInferResponses<typeof contract.getRoles>;

        export const action = {
          contract: tsr.routeWithMiddleware(contract.getRoles)< // this must be named contract as per my setup in this project
            { decodedJwt: z.infer<typeof JwtPayloadSchema> }, // Middleware context type
            Record<string, never> // Request context type (empty if not used)
          >({
            middleware: [secureByAuthentication], // Apply the authentication middleware
            handler: async (
              { query }: ContractRequest,
              { request } // Access decodedJwt from request.decodedJwt
            ): Promise<ContractResponse> => {
              // Your API logic here
              const userId = request.decodedJwt.id; // Example: Access user ID from JWT

              // ... (implementation details) ...

              return {
                status: 200,
                body: [], // Return appropriate body
              };
            },
          }),
        };
        ```
-   **Error Handling:** Use `TsRestResponseError` for structured error responses as defined in your contract's `ErrorResponse` schema.

### 1.3 Update the TS-REST Router

Ensure your new endpoint is added to the main TS-REST router.

-   **Location:** `src/app/api/v1/_contracts/index.ts`
-   **Action:** Import your new endpoint's contract and action, then add it to the `appRouter`.

### 1.4 Generate TS-REST Client and Router Files

After defining a new contract or modifying an existing one, you **must** run the generation scripts to update the client and router files.

-   **Commands:**
    ```bash
    npm run generate:tsrest
    npm run generate:tsrest:client
    ```
-   **Purpose:**
    *   `npm run generate:tsrest`: Updates the main TS-REST router (`src/app/api/v1/[...ts-rest]/route.ts`) to include your new endpoint.
    *   `npm run generate:tsrest:client`: Generates or updates the typed client functions in `src/app/api/v1/_client/client.ts`. This is crucial for client-side consumption.

## 2. Using the TS-REST Client

Once `npm run generate:tsrest:client` has been run, your new API endpoint will be available as a typed function in `src/app/api/v1/_client/client.ts`.

-   **Import:** You can import the specific function directly from `@/app/api/v1/_client/client`.
-   **Example Usage (from `src/app/api/v1/_client/client.ts` comments):**
    ```typescript
    // In your client-side or server-side component/logic:
    import { getRoles } from "@/app/api/v1/_client/client"; // Example for getRoles

    async function fetchData() {
      // For GET requests where no body is required, pass an empty object.
      const response = await getRoles({
        query: {
          resourceType: "ORGANIZATION",
          resourcePath: "org:some-uuid",
        },
      });

      if (response.status === 200) {
        const roles = response.body; // Fully typed data
        console.log("Roles:", roles);
      } else {
        const error = response.body; // Fully typed error
        console.error("Error fetching roles:", error);
      }
    }

    // For POST requests where a body is required:
    import { postRoles } from "@/app/api/v1/_client/client";

    async function createRole() {
      const response = await postRoles({
        body: {
          name: "New Role",
          resourceType: "ORGANIZATION",
          resourceId: "some-org-id",
          permissions: [{ permissionId: "some-perm-id", type: "ALLOW" }],
        },
      });

      if (response.status === 201) {
        const newRole = response.body;
        console.log("Role created:", newRole);
      } else {
        const error = response.body;
        console.error("Error creating role:", error);
      }
    }
    ```
-   **Crucially:** **Do not directly call or import the handler function (e.g., `action.getRoles`) from the contract file (`src/app/api/v1/_contracts/<feature-area>/<endpoint-name>.ts`) in your client-side code.** Always use the generated client functions from `src/app/api/v1/_client/client.ts`. This ensures proper serialization, deserialization, and adherence to the API contract.

## 3. Writing Tests for API Endpoints

Comprehensive testing is essential for API stability. Create dedicated test files for each endpoint.

-   **Location:** `src/app/api/v1/_contracts/<feature-area>/<endpoint-name>.test.ts`
-   **Framework:** Jest and Supertest are used for API testing.
-   **Helper Functions (from `src/app/api/v1/_contracts/test-utils.ts`):**
    *   `createApiTestServer()`: Initializes a test HTTP server for API requests. Call in `beforeAll`.
    *   `closeApiTestServer(server)`: Closes the test server. Call in `afterAll`.
    *   `flushDatabase(expect)`: Clears the database before each test. Important for isolated test runs.
    *   `signInTestAccount(botNum, revoke, falseJwt)`:
        *   Simulates user sign-in.
        *   `botNum`: There are only **two predefined bots** (bot 1 and bot 2) available for testing. Do not expect or attempt to use more than two. These bots simulate distinct users for testing multi-user scenarios.
        *   Returns `userData` object containing `jwt` (for Authorization header), `sessionId`, and `decoded` JWT payload.
    *   `revokeSession(sessionId)`: Revokes a Clerk session. Essential for logging out test users and cleaning up.
    *   `generateRequestBodyFromClerkDataForOnboardingSetup(questions)`: Helps generate onboarding request bodies.
    *   `getTestPermissions()`: Fetches available permission definitions from the database for use in role creation.
-   **Authentication Tests:** Always include tests for unauthenticated and unauthorized access.
-   **Validation Tests:** Test cases for invalid request bodies, missing parameters, and incorrect data types.
-   **Success Cases:** Thoroughly test the happy path, including various valid inputs and expected outputs.
-   **Edge Cases:** Test scenarios like empty data, special characters, and boundary conditions.

### Example Test Structures:

#### GET Request Test Example (`getRoles.test.ts`):

```typescript
// src/app/api/v1/_contracts/roles/getRoles.test.ts (excerpt)
import request from "supertest";
import { createServer } from "http";
import {
  createApiTestServer,
  closeApiTestServer,
  signInTestAccount,
  flushDatabase,
  revokeSession,
  generateRequestBodyFromClerkDataForOnboardingSetup,
} from "../test-utils";
import db from "@/server/database/db";
import { z } from "zod";
import { CreateRoleRequest, ResourceType, Permission } from "../schema";

let server: ReturnType<typeof createServer>;

beforeAll(async () => {
  server = await createApiTestServer();
});

afterAll(async () => {
  await closeApiTestServer(server);
});

// Helper function to set up a complete resource hierarchy for testing
async function setupCompleteHierarchy(botNum: number = 1) {
  // ... (implementation to create org, team, project, workflow)
  const userData = await signInTestAccount(botNum, false, false);
  const questions = (await request(server).get("/onboarding/questions")).body;
  const onboardingRequestBody =
    await generateRequestBodyFromClerkDataForOnboardingSetup(questions);

  const onboardingResponse = await request(server)
    .post("/onboarding/setup")
    .set("Authorization", `Bearer ${userData.jwt}`)
    .send(onboardingRequestBody);

  const orgId = onboardingResponse.body.orgId;

  return { ...userData, orgId }; // Simplified for example
}

describe("GET /roles", () => {
  it("should return 401 if no authentication token is provided", async () => {
    await flushDatabase(expect);
    const res = await request(server).get("/roles");
    expect(res.status).toBe(401);
  });
  it("should return 400 if resourceType is missing", async () => {
    await flushDatabase(expect);
    const { jwt, sessionId } = await setupCompleteHierarchy(1);

    const res = await request(server)
      .get("/roles?resourcePath=org:test-org")
      .set("Authorization", `Bearer ${jwt}`);

    expect(res.status).toBe(400);
    // expect(res.body.message).toContain("Query parameter 'resourceType': Required"); // Uncomment and adapt based on actual error message

    await revokeSession(sessionId);
  });

  it("should return 200 with roles for ORGANIZATION", async () => {
    await flushDatabase(expect);
    const { jwt, sessionId, orgId } = await setupCompleteHierarchy(1);
    // Assume createRoleForResource is a helper to create roles
    // const createdRole = await createRoleForResource(jwt, "ORGANIZATION", orgId, testPermissions, "Org Admin");

    const res = await request(server)
      .get(`/roles?resourceType=ORGANIZATION&resourcePath=org:${orgId}`)
      .set("Authorization", `Bearer ${jwt}`);

    expect(res.status).toBe(200);
    expect(Array.isArray(res.body)).toBe(true);
    // expect(res.body.length).toBe(1); // Check against created roles

    await revokeSession(sessionId);
  });
});
```

#### POST Request Test Example (`postRoles.test.ts`):

```typescript
// src/app/api/v1/_contracts/roles/postRoles.test.ts (excerpt)
import request from "supertest";
import { createServer } from "http";
import {
  createApiTestServer,
  closeApiTestServer,
  signInTestAccount,
  flushDatabase,
  revokeSession,
  generateRequestBodyFromClerkDataForOnboardingSetup,
} from "../test-utils";
import db from "@/server/database/db";
import { z } from "zod";
import { CreateRoleRequest, ResourceType, Permission } from "../schema";

let server: ReturnType<typeof createServer>;

beforeAll(async () => {
  server = await createApiTestServer();
});

afterAll(async () => {
  await closeApiTestServer(server);
});

async function setupUserAndOrg(botNum: number = 1) {
  const userData = await signInTestAccount(botNum, false, false);
  const questions = (await request(server).get("/onboarding/questions")).body;
  const onboardingRequestBody =
    await generateRequestBodyFromClerkDataForOnboardingSetup(questions);

  const onboardingResponse = await request(server)
    .post("/onboarding/setup")
    .set("Authorization", `Bearer ${userData.jwt}`)
    .send(onboardingRequestBody);

  return { ...userData, orgId: onboardingResponse.body.orgId };
}

async function getTestPermissions(): Promise<z.infer<typeof Permission>[]> {
  const permissionRecords = await db.permissionDefinition.findMany();
  return permissionRecords.map((p) => ({
    id: p.id,
    action: p.action,
  }));
}

describe("POST /roles", () => {
  it("should return 401 if no authentication token is provided", async () => {
    await flushDatabase(expect);
    const res = await request(server).post("/roles").send({});
    expect(res.status).toBe(401);
  });

  it("should return 400 if required fields are missing", async () => {
    await flushDatabase(expect);
    const { jwt, sessionId, orgId } = await setupUserAndOrg(1);
    const testPermissions = await getTestPermissions();

    const payload = {
      // name is missing
      description: "Test role description",
      resourceType: ResourceType.enum.ORGANIZATION,
      resourceId: orgId,
      permissions: [
        { permissionId: testPermissions[0].id, type: "ALLOW" as const },
      ],
    };

    const res = await request(server)
      .post("/roles")
      .set("Authorization", `Bearer ${jwt}`)
      .send(payload);

    expect(res.status).toBe(400);

    await revokeSession(sessionId);
  });

  it("should successfully create a new role with valid data and return 201", async () => {
    await flushDatabase(expect);
    const { jwt, sessionId, orgId } = await setupUserAndOrg(1);
    const testPermissions = await getTestPermissions();

    const createRolePayload: z.infer<typeof CreateRoleRequest> = {
      name: "Admin Role",
      description: "Role with administrative privileges for an organization",
      resourceType: ResourceType.enum.ORGANIZATION,
      resourceId: orgId,
      permissions: [
        { permissionId: testPermissions[0].id, type: "ALLOW" },
      ],
    };

    const res = await request(server)
      .post("/roles")
      .set("Authorization", `Bearer ${jwt}`)
      .send(createRolePayload);

    expect(res.status).toBe(201);
    expect(res.body.name).toBe(createRolePayload.name);
    // ... further assertions
    await revokeSession(sessionId);
  });
});
```

#### PATCH Request Test Example (`patchRole.test.ts`):

```typescript
// src/app/api/v1/_contracts/roles/patchRole.test.ts (excerpt)
import request from "supertest";
import { createServer } from "http";
import {
  createApiTestServer,
  closeApiTestServer,
  signInTestAccount,
  flushDatabase,
  revokeSession,
  generateRequestBodyFromClerkDataForOnboardingSetup,
} from "../test-utils";
import db from "@/server/database/db";
import { z } from "zod";
import { CreateRoleRequest, ResourceType, Permission } from "../schema";

let server: ReturnType<typeof createServer>;

beforeAll(async () => {
  server = await createApiTestServer();
});

afterAll(async () => {
  await closeApiTestServer(server);
});

async function setupUserAndOrg(botNum: number = 1) {
  const userData = await signInTestAccount(botNum, false, false);
  const questions = (await request(server).get("/onboarding/questions")).body;
  const onboardingRequestBody =
    await generateRequestBodyFromClerkDataForOnboardingSetup(questions);

  const onboardingResponse = await request(server)
    .post("/onboarding/setup")
    .set("Authorization", `Bearer ${userData.jwt}`)
    .send(onboardingRequestBody);

  return { ...userData, orgId: onboardingResponse.body.orgId };
}

async function getTestPermissions(): Promise<z.infer<typeof Permission>[]> {
  const permissionRecords = await db.permissionDefinition.findMany();
  return permissionRecords.map((p) => ({
    id: p.id,
    action: p.action,
  }));
}

async function createTestRole(
  jwt: string,
  orgId: string,
  permissions: z.infer<typeof Permission>[],
  name = "Test Role",
  description?: string
) {
  const createRolePayload: z.infer<typeof CreateRoleRequest> = {
    name,
    description,
    resourceType: ResourceType.enum.ORGANIZATION,
    resourceId: orgId,
    permissions: [
      { permissionId: permissions[0].id, type: "ALLOW" as const },
    ],
  };

  const res = await request(server)
    .post("/roles")
    .set("Authorization", `Bearer ${jwt}`)
    .send(createRolePayload);

  expect(res.status).toBe(201);
  return res.body;
}

describe("PATCH /roles/:roleId", () => {
  it("should return 401 if no authentication token is provided", async () => {
    await flushDatabase(expect);
    const res = await request(server)
      .patch("/roles/123e4567-e89b-12d3-a456-426614174000")
      .send({ name: "Updated Role" });
    expect(res.status).toBe(401);
  });

  it("should return 404 when role does not exist", async () => {
    await flushDatabase(expect);
    const { jwt, sessionId } = await setupUserAndOrg(1);

    const nonExistentRoleId = "123e4567-e89b-12d3-a456-426614174000";
    const res = await request(server)
      .patch(`/roles/${nonExistentRoleId}`)
      .set("Authorization", `Bearer ${jwt}`)
      .send({ name: "Updated Role" });

    expect(res.status).toBe(404);
    expect(res.body.message).toBe("Role not found");

    await revokeSession(sessionId);
  });

  it("should successfully update role name", async () => {
    await flushDatabase(expect);
    const { jwt, sessionId, orgId } = await setupUserAndOrg(1);
    const testPermissions = await getTestPermissions();

    const createdRole = await createTestRole(
      jwt,
      orgId,
      testPermissions,
      "Original Name"
    );

    const res = await request(server)
      .patch(`/roles/${createdRole.id}`)
      .set("Authorization", `Bearer ${jwt}`)
      .send({ name: "Updated Role Name" });

    expect(res.status).toBe(200);
    expect(res.body.name).toBe("Updated Role Name");

    await revokeSession(sessionId);
  });
});
```

## 4. Running Tests

To run specific test files efficiently, use the `test:args` script.

-   **Command:**
    ```bash
    npm run test:args -- <relativePathToDotTestDotTSFile>
    ```
-   **Example:**
    ```bash
    npm run test:args -- src/app/api/v1/_contracts/roles/getRoles.test.ts
    ```
-   **Important:**
    *   **Always include `--` before the file path.** This ensures that `jest` receives the path as an argument rather than `npm` interpreting it.
    *   Avoid running `npm test` or `npm run test` directly during development for single files, as these commands run the entire test suite, which is much slower.

## 5. Testing Utilities (Bots and Sessions)

The testing environment provides specific utilities for managing user sessions and testing with multiple users.

-   **Bots:** Only **two (2) predefined bots** are available for simulating users in tests. These are accessed via `signInTestAccount(1, ...)` and `signInTestAccount(2, ...)`. Do not attempt to use more than these two.
-   **Logging In:** Use `signInTestAccount()` to obtain a JWT and session information for a test user.
-   **Logging Out:** After each test, it is crucial to call `revokeSession(sessionId)` for any signed-in test accounts to ensure proper cleanup and isolation between tests. This prevents session conflicts and ensures a clean state for subsequent tests.

## 6. Client Interaction: Use TS-REST Client ONLY

**This is a critical rule for maintaining the integrity and type safety of the application.**

-   **DO NOT directly use or import the API endpoint's handler function (e.g., `action.getRoles`) in your frontend or other client-side code.**
-   **ALWAYS import and use the generated TS-REST client functions from `src/app/api/v1/_client/client.ts`.** These functions (`getAccountUserId`, `patchAccount`, `getRoles`, `postRoles`, etc.) are automatically generated and correctly handle the communication with your backend API, including request/response serialization and deserialization, and authentication headers.

Following these guidelines will ensure a robust and maintainable API development workflow.

# Feature Creation Guidelines

This document outlines best practices and common patterns to follow when creating new features and API implementations in the codebase.

## API Implementation - Action Object Structure

- **Always use `contract` as the key within the `action` object for API route handlers. as well as inside the contract itself**
  - This ensures consistency with the `@ts-rest` client and serverless integration.
  - **DO NOT** use the specific method name (e.g., `postTeam`, `getRoles`) as the key.

### ✅ DO: Correct `action` Object Structure

```typescript
// src/app/api/v1/_contracts/roles/getRoles.ts (Example)
export const action = {
  contract: tsr.routeWithMiddleware(contract.contract)<
    { decodedJwt: z.infer<typeof JwtPayloadSchema> },
    Record<string, never>
  >({
    // ... handler implementation ...
  }),
};
```

```typescript
// src/app/api/v1/_contracts/onboarding/onboardingQuestions.ts (Example)
export const action = {
  contract: tsr.routeWithMiddleware(contract.contract)<
    { decodedJwt: z.infer<typeof JwtPayloadSchema> },
    Record<string, never>
  >({
    // ... handler implementation ...
  }),
};
```

### ❌ DON'T: Incorrect `action` Object Structure

```typescript
// src/app/api/v1/_contracts/team/postTeam.ts (Previously incorrect example)
export const action = {
  postTeam: tsr.routeWithMiddleware(contract.postTeam)< // this needed to be contract and contract.contract instead of postTeam and contract.postTeam
    {
      decodedJwt: z.infer<typeof JwtPayloadSchema>;
    },
    Record<string, never>
  >({
    // ... handler implementation ...
  }),
};
```

### MISTAKES

1. Not running the test after creating the endpoint and its test. 
2. running with pnpm instead of npm.
3. chaning jest config rather than using the correct test comman "npm run test:args -- relative_path"